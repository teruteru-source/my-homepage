#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cassert>
#include <numeric>
#include <iomanip>
#include <array>
#include <set>

std::vector<int> Parametrization_Degrees = {-1,
  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  1,-1,-1,1,1,-1,1,-1,1,1,
  1,-1,-1,1,-1,-1,1,-1,-1,2,
  -1,1,3,2,2,1,-1,-1,2,2,
  -1,4,2,2,2,5,-1,2,1,-1,
  2,3,2,-1,2,-1,-1,-1,-1,-1,
  2,2,4,2,2,-1,5,-1,2,4,
  -1,4,3,-1,-1,6,-1,40,2,-1,
  -1,4,2,-1,4,-1,-1,8,-1,-1,
  -1,-1,-1,2,-1,-1,-1,16,-1,12
};//conductor Nの楕円曲線のmodular degree，[Cremona]より

bool is_Prime(int p){
  for(int l=2;l*l<=p;l++) if(p%l == 0) return false;
  return true;
}//pが素数か

struct M_symbols{
  int c,d;
  M_symbols(int a,int b){c=a,d=b;}
};//M-symbols

bool is_equivalent(int N, M_symbols m1,M_symbols m2,std::vector<int> &units){
  for(int u : units){
    if((u*m1.c-m2.c)%N == 0 && (u*m1.d - m2.d)%N == 0) return true;
  }
  return false;
}//2つのM-symbolsが同値かどうか

std::vector<M_symbols> enumerate_M_symbols(int N,std::vector<int> &units){
  std::vector<M_symbols> ms;
	for(int c=0;c<N;c++) ms.push_back(M_symbols{c,1});
	for(int d=0;d<N;d++){
	  if(std::gcd(d,N) > 1) ms.push_back(M_symbols{1,d});
	  else units.push_back(d);
	}
	std::vector<M_symbols> prime;
	for(int c=2;c<N;c++){
		if(N % c != 0) continue;
		for(int d=1;d<N;d++){
			if(std::gcd(c,d) == 1 && std::gcd(d,N) > 1){
				bool ok = true;
				for(int i=0;i<ssize(prime);i++){
					if(is_equivalent(N,M_symbols{c,d},prime[i],units)){
						ok = false;
						break;
					}
					if(!ok) break;
				}
				if(ok) prime.push_back(M_symbols{c,d});
			}
		}
	}
	for(int i=0;i<prime.size();i++) ms.push_back(prime[i]);
	return ms;
}//NにおけるM-symbolsを列挙

struct fraction{
  int numerator,denominator;
  
  fraction() : numerator(0), denominator(1) {}
  fraction(int x) : numerator(x), denominator(1) {}
  fraction(int x,int y){
    assert(y!=0);
    int G = std::gcd(x,y);
    x /= G,y /= G;
    numerator=x,denominator=y;
    if(denominator<0) numerator = -numerator, denominator = -denominator;
  }//x/y
  
  fraction operator+(const fraction &o){
    fraction res;
    res.denominator = std::lcm(denominator,o.denominator);
    res.numerator = res.denominator/denominator*numerator + res.denominator/o.denominator*o.numerator;
    int G = std::gcd(res.denominator,res.numerator);
    res.denominator /= G,res.numerator /= G;
    return res;
  }
  fraction operator+(int x){return *this + fraction(x,1);}
  
  fraction operator-(const fraction &o){
    fraction res(o.numerator,-o.denominator);
    return *this + res;
  }
  fraction operator-(int x){return *this - fraction(x,1);}
  fraction operator-(){return fraction(-numerator,denominator);}
  
  fraction operator*(const fraction &o){return fraction(numerator*o.numerator,denominator*o.denominator);}
  fraction operator*(int x){return fraction(numerator*x,denominator);}
  fraction operator/(const fraction &o){return fraction(numerator*o.denominator,denominator*o.numerator);}
  fraction operator/(int x){return fraction(numerator,denominator*x);}
  
  fraction operator+=(const fraction &o){*this = *this + o; return *this;}
  fraction operator+=(const int &o){*this = *this + o; return *this;}
  fraction operator-=(const fraction &o){*this = *this - o; return *this;}
  fraction operator-=(const int &o){*this = *this - o; return *this;}
  fraction operator*=(const fraction &o){*this = *this * o; return *this;}
  fraction operator*=(const int &o){*this = *this * o; return *this;}
  fraction operator/=(const fraction &o){*this = *this / o; return *this;}
  fraction operator/=(const int &o){*this = *this / o; return *this;}
  
  fraction operator%(int x){
    numerator %= (x*denominator);
    if(numerator<0) numerator += x*denominator;
    return fraction(numerator,denominator);
  }
  
  bool operator==(const fraction &o) const{return numerator*o.denominator == o.numerator*denominator;}
  bool operator!=(const fraction &o) const{return !(*this == o);}
  bool operator==(int x) const{return numerator == x*denominator;}
  bool operator!=(int x) const{return !(*this==x);}
  bool operator<(const fraction &o) const{return numerator*o.denominator < o.numerator*denominator;}
  bool operator>(const fraction &o) const{return o < *this;}
  bool operator<=(const fraction &o) const{return !(o < *this);}
  bool operator>=(const fraction &o) const{return !(o > *this);}
  
  friend std::ostream& operator<<(std::ostream& os,const fraction &x){
    os<<x.numerator<<'/'<<x.denominator;
    return os;
  }
  
  fraction inv(){
    assert(numerator != 0);
    return fraction(denominator,numerator);
  }
  
  double val(){
    return (double)numerator / (double)denominator;
  }
};//分数の構造体

int find_equivalent(int N, M_symbols m,std::vector<M_symbols> &ms, std::vector<int> &units){
  for(int i=0;i<ms.size();i++){
    if(is_equivalent(N,m,ms[i],units)) return i;
  }
  return -1;
}//同値なM-symbolsをリストから見つける

template<class T> struct Matrix {
    std::vector<std::vector<T>> val;
    Matrix(int n, int m, T x = 0) : val(n, std::vector<T>(m, x)) {}
    void init(int n, int m, T x = 0) { val.assign(n, std::vector<T>(m, x)); }
    size_t size() const { return val.size(); }
    inline std::vector<T>& operator [] (int i) { return val[i]; }
};//行列の構造体

Matrix<fraction> Construct_Coefficient_Matrix(int N, std::vector<M_symbols> &ms, std::vector<int> &units){
  int l = ms.size();
  Matrix<fraction> mat(2*l,l);
  for(int i=0;i<l;i++){//二項関係式
    int c = ms[i].c,d = ms[i].d;
    mat[i][i] = fraction(1);
    int id = find_equivalent(N,M_symbols(-d,c),ms,units);
    if(id == -1) exit(1);
    mat[i][id] = fraction(1);
  }
  for(int i=0;i<l;i++){//三項関係式
    int c = ms[i].c,d = ms[i].d;
    mat[l+i][i] = fraction(1);
    int id1 = find_equivalent(N,M_symbols(c+d,-c),ms,units);
    int id2 = find_equivalent(N,M_symbols(d,-c-d),ms,units);
    if(id1 == -1 || id2 == -1) exit(1);
    mat[l+i][id1] = fraction(1);
    mat[l+i][id2] = fraction(1);
  }
  return mat;
}
//二項関係式/三項関係式からなる1次連立方程式の係数行列を構成

fraction abs(fraction x){return std::max(-x,x);}//|x|

template<class T> int GaussJordan(Matrix<T> &A, bool is_extended = false) {
    int n = A.size(), m = A[0].size();
    int pivot_col_limit = is_extended ? m - 1 : m;
    int rank = 0;
    
    std::vector<int> pivot_cols;

    // 前進消去
    for (int j = 0; j < pivot_col_limit && rank < n; ++j) {
        int pivot_row = rank;
        while (pivot_row < n && A[pivot_row][j] == 0) pivot_row++;
        
        if (pivot_row == n) continue;

        std::swap(A[rank], A[pivot_row]);
        
        // ピボット係数を1にする（行全体を割る）
        T div = A[rank][j];
        for (int j0 = j; j0 < m; ++j0) A[rank][j0] /= div;
        
        for (int i0 = rank + 1; i0 < n; ++i0) {
            if (A[i0][j] == 0) continue;
            T factor = A[i0][j];
            for (int j0 = j; j0 < m; ++j0) {
                A[i0][j0] -= factor * A[rank][j0];
            }
        }
        pivot_cols.push_back(j);
        rank++;
    }

    // 後退消去
    // rank-1 行目から上に向かって消去していく
    for (int i = rank - 1; i >= 0; --i) {
        int pj = pivot_cols[i];
        for (int i0 = i - 1; i0 >= 0; --i0) {
            if (A[i0][pj] == 0) continue;
            T factor = A[i0][pj];
            for (int j0 = pj; j0 < m; ++j0) {
                A[i0][j0] -= factor * A[i][j0];
            }
        }
    }

    return rank;
}
//Gaussの消去法

template<class T> std::vector<std::vector<T>> solve_homogeneous(Matrix<T> &A,std::vector<int> &basis) {
    int n = A.size();
    int m = A[0].size();
    
    int rank = GaussJordan(A, false);

    std::vector<int> pivot_at_col(n, -1);
    std::vector<bool> is_pivot_col(m, false);
    int r = 0;
    for (int j = 0; j < m && r < rank; ++j) {
        if (A[r][j] != 0) { // GaussJordanが正しければここは必ず1
            pivot_at_col[r] = j;
            is_pivot_col[j] = true;
            r++;
        }
    }

    std::vector<std::vector<T>> rel;
    for (int j = 0; j < m; ++j) {
        if (is_pivot_col[j]) continue;
        basis.push_back(j);
        
        std::vector<T> v(m, 0);
        v[j] = 1;
        
        for (int row = 0; row < rank; ++row) {
            int p_col = pivot_at_col[row];
            v[p_col] = -A[row][j];
        }
        rel.push_back(v);
    }
    return rel;
}
//行列Aの核空間の基底を求める

template<class T> std::vector<std::vector<T>> find_eigenvectors(Matrix<T> &A, T lambda){
  int n = A.size();
  Matrix<T> B = A;
  for(int i=0;i<n;i++) B[i][i] -= lambda;
  std::vector<int> emp;
  return solve_homogeneous(B,emp);
}
//固有値lambdaに対応する固有空間を計算

template<class T> void print_relations(const std::vector<std::vector<T>>& pivot, int m) {
    std::cout << "--- 各変数の関係式 (c_i は自由変数のパラメータ) ---" << std::endl;
    for (int j = 0; j < m; ++j) {
        std::cout << "x_" << j << " = ";
        bool first = true;
        for (size_t k = 0; k < pivot.size(); ++k) {
            T val = pivot[k][j];
            if (val == 0) continue;
            
            if (!first && val > 0) std::cout << " + ";
            if (val < 0) std::cout << " - ";
            
            // 1/-1 のときは数字を省略（絶対値が1でない場合のみ表示）
            T abs_val = (val < 0) ? -val : val;
            if (abs_val != 1) std::cout << abs_val;
            
            std::cout << "c_" << k;
            first = false;
        }
        if (first) std::cout << "0";
        std::cout << std::endl;
    }
}
// 関係式を表示する関数

int extend_gcd(int a, int b, int &x, int &y){
  if (b == 0) {
    x = 1;
    y = 0;
    return a;
  } else {
      int d = extend_gcd(b, a % b, y, x);
      y -= a / b * x;
      return d;
  }
}
//Euclidの消去法を拡張
//ax+by = gcd(a,b)の整数解をひとつ求める

struct Cusp {int a,d;};//カスプa/dの表示

std::vector<Cusp> enumerate_cusps(int N) {
  std::vector<Cusp> cusps;

  for (int d = 1; d <= N; ++d) {
    if (N % d == 0) {
      int m = std::gcd(d, N / d);
        
      std::set<int> found_a_mods;
      for (int a = 1; a <= d || a <= m; ++a) {
        if (std::gcd(a, d) == 1) {
          int a_mod = a % m;
          if (found_a_mods.find(a_mod) == found_a_mods.end()) {
            found_a_mods.insert(a_mod);
            cusps.push_back({a,d});
          }
        }
        if (found_a_mods.size() == (m == 0 ? 1 : 0)) break;
      }
    }
  }
  return cusps;
}
//Γ_0(N)のカスプ(の同値類)を列挙する

std::array<Cusp,2> delta(M_symbols &m){
  int a,b;
  extend_gcd(m.d,-m.c,a,b);
  if(a*m.d - b*m.c == -1){a=-a,b=-b;}//ad-bc=1
  std::array<Cusp,2> res;
  res[0] = Cusp{a,m.c};
  res[1] = Cusp{b,m.d};
  return res;
}
//δ(m)を計算
//array[0]-array[1]が実際の戻り値

bool cusps_are_equivalent(int N,Cusp &c1,Cusp &c2,std::vector<int> &units){
  for(int u : units){
    if((c2.d-u*c1.d)%N == 0 && (u*c2.a-c1.a)%std::gcd(c1.d,N) == 0){
      return true;
    }
  }
  return false;
}
//2カスプが同値か判定する

Matrix<fraction> Construct_delta_Matrix(int N,std::vector<M_symbols> &ms,std::vector<int> &pivot,std::vector<int> &units,std::vector<Cusp> &cusps){
  Matrix<fraction> res(cusps.size(),pivot.size());
  for(int i=0;i<pivot.size();i++){
    std::array<Cusp,2> D = delta(ms[pivot[i]]);
    for(int j=0;j<cusps.size();j++) if(cusps_are_equivalent(N,D[0],cusps[j],units)){
      res[j][i] += fraction(1);
      break;
    }
    for(int j=0;j<cusps.size();j++) if(cusps_are_equivalent(N,D[1],cusps[j],units)){
      res[j][i] += fraction(-1);
      break;
    }
  }
  return res;
}
//写像δの基底に対する表現行列を構成する

std::vector<int> calc_HN(int N,std::vector<M_symbols> &ms,std::vector<int> &pivot,std::vector<int> &units,std::vector<Cusp> cusps){
  Matrix<fraction> dM = Construct_delta_Matrix(N,ms,pivot,units,cusps);
  std::vector<int> basis;
  std::vector<std::vector<fraction>> res = solve_homogeneous(dM,basis);
  return basis;
}
//H(N)の構造を決定する

Matrix<fraction> Construct_Conjugate_Matrix(int N,std::vector<int> &HN,std::vector<int> &pivot,std::vector<M_symbols> &ms,std::vector<std::vector<fraction>> &rel,std::vector<int> &units){
  Matrix<fraction> res(HN.size(),HN.size());
  for(int i=0;i<HN.size();i++){
    M_symbols search = M_symbols(-ms[pivot[HN[i]]].c,ms[pivot[HN[i]]].d);
    int tag = -1;
    for(int j=0;j<ms.size();j++) if(is_equivalent(N,search,ms[j],units)){
      tag = j;
      break;
    }
    assert(tag != -1);
    for(int j=0;j<HN.size();j++) res[j][i] = rel[j][tag];
  }
  return res;
}
//H(N)の基底に対する写像*(involution)の表現行列を構成する

template<class T> Matrix<T> transpose(Matrix<T> &A){
  int n = A.size(), m = A[0].size();
  Matrix<T> res(m,n);
  for(int i=0;i<n;i++) for(int j=0;j<m;j++) res[j][i] = A[i][j];
  return res;
}
//行列を転置する

void normalize(std::vector<fraction> &x){
  int LCM = 1;
  for(int i=0;i<x.size();i++) LCM = std::lcm(LCM,x[i].denominator);
  for(int i=0;i<x.size();i++) x[i] *= LCM;
}
//ベクトルを整数係数に変換する

bool is_rectangular(std::vector<fraction> &v_plus,std::vector<fraction> &v_minus){
  for(int i=0;i<v_plus.size();i++) if((v_plus[i]-v_minus[i])%2 != 0) return true;
  return false;
}
//格子E_fがrectangularかどうか判定する

struct Modular_symbol{Cusp num1,num2;};
//Modular_symbol,{num1,num2}に対する構造体

std::vector<int> continued_fraction(Cusp &c){
  std::vector<int> res;
  int p=c.a,q=c.d;
  while(q != 0){
    int a = p/q, r = p%q;
    res.push_back(a);
    p=q,q=r;
  }
  return res;
}
//連分数展開

std::vector<Cusp> Construct_Fractional_Convergence_Sequence(Cusp &c){
  std::vector<int> C = continued_fraction(c);
  std::vector<Cusp> res;
  int pre_p = 1, pre_q = 0, p = C[0], q = 1;
  res.push_back(Cusp{p,q});
  for(int i=1;i<C.size();i++){
    int next_p = C[i]*p + pre_p;
    int next_q = C[i]*q + pre_q;
    pre_p=p,pre_q=q,p=next_p,q=next_q;
    res.push_back(Cusp{p,q});
  }
  return res;
}
//分数収束列の構成

M_symbols Modular_symbol_to_M_symbol(Modular_symbol M){
  return M_symbols((M.num1.d*M.num2.a-M.num1.a*M.num2.d)*M.num2.d,M.num1.d);
}
//Modular_symbolを対応するM_symbolsに変換
//渡されるModular_symbolは一つのM_symbolsに変換できるものになっている

std::vector<int> Modular_symbol_to_M_symbols(int N,Modular_symbol M,std::vector<M_symbols> &ms,std::vector<int> &units){
  std::vector<Cusp> res1 = Construct_Fractional_Convergence_Sequence(M.num1);
  std::vector<Cusp> res2 = Construct_Fractional_Convergence_Sequence(M.num2);
  int l1 = res1.size(), l2 = res2.size();
  std::vector<int> cnt(ms.size(),0);
  for(int i=0;i<l2-1;i++){
    M_symbols m = Modular_symbol_to_M_symbol({res2[i],res2[i+1]});
    int id = find_equivalent(N,m,ms,units);
    cnt[id]++;
  }
  for(int i=0;i<l1-1;i++){
    M_symbols m = Modular_symbol_to_M_symbol({res1[i],res1[i+1]});
    int id = find_equivalent(N,m,ms,units);
    cnt[id]--;
  }
  return cnt;
}
//一般のModular_symbolをM_symbolsの和に変換する

int Kronecker(int a, int n) {
  if (n == 0) return (a == 1 || a == -1) ? 1 : 0;
  if (n < 0){
    int res = (a < 0) ? -1 : 1;
    return res * Kronecker(a, -n);
  }
  if (n % 2 == 0) {
    if (a % 2 == 0) return 0;
    int res = 1;
    while (n % 2 == 0) {
      int r8 = a % 8;
      if (r8 == 3 || r8 == 5) res = -res;
      n /= 2;
    }
    return res * Kronecker(a, n);
  }
  int res = 1;
  a %= n;
  if (a < 0) a += n;

  while (a != 0) {
    while (a % 2 == 0) {
      a /= 2;
      int r8 = n % 8;
      if (r8 == 3 || r8 == 5) res = -res;
    }
    int temp = a; a = n; n = temp;
    if ((a % 4) == 3 && (n % 4) == 3) res = -res;
    a %= n;
  }
  return (n == 1) ? res : 0;
}
//Kronecker記号，(a/n)を計算する

std::vector<int> gamma_l(int N,int L,std::vector<M_symbols> &ms,std::vector<int> &units){
  std::vector<int> res(ms.size(),0);
  for(int l=0;l<L;l++){
    std::vector<int> cnt = Modular_symbol_to_M_symbols(N,Modular_symbol{Cusp(0,1),Cusp(l,L)},ms,units);
    for(int i=1;i<ms.size();i++) res[i] += Kronecker(-l,L) * cnt[i];
  }
  return res;
}
//γ_L = sum_{l in Z/LZ}{Kronecker(-l/L) * {0,l/L}}を計算する

int m_minus(int N,int L,std::vector<M_symbols> &ms,std::vector<int> &units,
            std::vector<std::vector<fraction>> &rel,std::vector<int> &HN,std::vector<fraction> &v_minus){
  std::vector<int> res = gamma_l(N,L,ms,units);
  
  std::vector<fraction> cnt(HN.size(),0);
  for(int i=0;i<ms.size();i++){
    for(int j=0;j<HN.size();j++){
      cnt[j] += rel[HN[j]][i] * res[i];
    }
  }
  
  int val = 0;
  for(int i=0;i<HN.size();i++){
    fraction V = v_minus[i] * cnt[i];
    assert(V.denominator == 1);
    val += V.numerator;
  }
  return val;
}
//m^-(L,f) = γ_L・v^-を計算

Modular_symbol M_symbols_to_Modular_symbol(M_symbols &m){
  int a,b;
  extend_gcd(m.d,-m.c,a,b);
  if(a*m.d - b*m.c == -1){a=-a,b=-b;}//ad-bc=1
  Modular_symbol res;
  res.num1 = Cusp{b,m.d};
  res.num2 = Cusp{a,m.c};
  return res;
}
//Modular_symbolをM_symbolsに変換

std::vector<int> Hecke(int p,int N,Modular_symbol &m,std::vector<M_symbols> &ms,std::vector<int> &units){
  std::vector<int> cnt = Modular_symbol_to_M_symbols(N,Modular_symbol{Cusp(p*m.num1.a,m.num1.d),Cusp(p*m.num2.a,m.num2.d)},ms,units);

  for(int r=0;r<p;r++){
    std::vector<int> par = Modular_symbol_to_M_symbols(N,Modular_symbol{Cusp(m.num1.a + m.num1.d * r,m.num1.d * p),Cusp(m.num2.a + m.num2.d * r,m.num2.d * p)},ms,units);
    for(int i=0;i<ms.size();i++) cnt[i] += par[i];
  }
  return cnt;
}
//T_p(m)の各項を計算する

std::vector<fraction> Hecke_operator(int p,int N,std::vector<M_symbols> &ms,std::vector<int> &units,
        std::vector<int> &HN,std::vector<int> &pivot,std::vector<std::vector<fraction>> &rel,std::vector<fraction> &eigenspace_1){
  assert(N % p != 0);
  assert(HN.size() == eigenspace_1.size());
  
  std::vector<fraction> res(HN.size(),0);
  
  for(int i=0;i<eigenspace_1.size();i++)
  {
    Modular_symbol m = M_symbols_to_Modular_symbol(ms[pivot[HN[i]]]);
    std::vector<int> val = Hecke(p,N,m,ms,units);
    for(int j=0;j<ms.size();j++){
      for(int k=0;k<HN.size();k++){
        res[k] += rel[HN[k]][j] * val[j] * eigenspace_1[i];
      }
    }
  }
  /*for(int i=0;i<res.size();i++){
    std::cerr<<res[i]<<" "<<eigenspace_1[i]<<"\n";
  }*/
  return res;
}
//上の計算結果をまとめてT_p(m)として返す

fraction n_pf(int p,int N,std::vector<M_symbols> &ms,std::vector<int> &units,std::vector<fraction> &eigenspace_1,
        std::vector<std::vector<fraction>> &rel,std::vector<int> &HN){
  std::vector<int> res(ms.size(),0);
  for(int a=0;a<p;a++){
    std::vector<int> cnt = Modular_symbol_to_M_symbols(N,Modular_symbol{Cusp(0,1),Cusp(a,p)},ms,units);
    for(int i=1;i<ms.size();i++) res[i] += cnt[i];
  }
  std::vector<fraction> cnt(HN.size(),0);
  for(int i=0;i<ms.size();i++){
    for(int j=0;j<HN.size();j++){
      cnt[j] += rel[HN[j]][i] * res[i];
    }
  }
  //std::cerr<<cnt[0]<<" "<<cnt[1]<<"\n";
  //std::cerr<<eigenspace_1[0]<<" "<<eigenspace_1[1]<<"\n";
  fraction ratio;
  for(int i=0;i<cnt.size();i++){
    if(eigenspace_1[i] == 0) continue;
    ratio = cnt[i] / eigenspace_1[i];
    for(int j=0;j<cnt.size();j++) assert(eigenspace_1[i] * ratio == cnt[i]);
    break;
  }
  return ratio;
}
//Hecke-Operator,T_p(m)に対するn(p,f)を計算する

void print_result(int N,int L,fraction par1,fraction par2,fraction M_minus,bool Rectangular){
  fraction res = fraction(N).inv() * par1 * abs(par2*M_minus).inv() * Parametrization_Degrees[N];
  if(!Rectangular) res *= 2;
  
  std::cout<<"L(sym^2(f),2)/(L(f,1)*L(f TENSOR chi_l,1)) is: "<<res<<"*sqrt("<<L<<")*pi = ";
  double Val = res.val();
  Val *= std::numbers::pi * sqrt(L);
  std::cout<<std::setprecision(16)<<Val<<"\n";
}
//結果を出力

int main(){
  std::cout<<
  "Please Input the number N for which you wish to know the value, L(sym^2(f),2)/(L(f,1)*L(f TENSOR chi_l,1)). :\n";
  int N;
  std::cin>>N;
  if(Parametrization_Degrees[N] == -1){
    std::cout<<"N is not valid\n";
    return 0;
  }
  std::vector<int> units;
  std::vector<M_symbols> ms = enumerate_M_symbols(N,units);
  Matrix<fraction> init = Construct_Coefficient_Matrix(N,ms,units);
  std::vector<int> pivot;
  std::vector<std::vector<fraction>> rel = solve_homogeneous(init,pivot);
  
  std::vector<Cusp> cusps = enumerate_cusps(N);
  std::vector<int> HN = calc_HN(N,ms,pivot,units,cusps);
  if(HN.empty()){
    std::cout<<"There is no newform f whose conductor is N\n";
    return 0;
  }
  if(HN.size()>2){
    std::cout<<"There are more than one newform whose conductor is N\n";
    return 0;
  }
  
  Matrix<fraction> Conj = Construct_Conjugate_Matrix(N,HN,pivot,ms,rel,units);
  std::vector<fraction> eigenspace_1 = find_eigenvectors(Conj,fraction(1))[0];//+1-固有空間のspan
  normalize(eigenspace_1);
  Matrix<fraction> Trans_Conj = transpose(Conj);
  std::vector<fraction> v_plus = find_eigenvectors(Trans_Conj,fraction(1))[0];//+1 left-eigenvector
  std::vector<fraction> v_minus = find_eigenvectors(Trans_Conj,fraction(-1))[0];//-1 left-eigenvector
  normalize(v_plus),normalize(v_minus);
  bool Rectangular = is_rectangular(v_plus,v_minus);
  if(Rectangular) std::cout<<"The period lattice is rectangular\n";
  else std::cout<<"The period lattice is non-rectangular\n";
  
  for(int L=3;L<10000;L+=4)
  {
    if(!is_Prime(L)) continue;
    if(N % L == 0) continue;
    
    if(Kronecker(-L,-N) != 1){
      std::cout<<"The sign is not valid\n";
      continue;
    }
    
    fraction M_minus = m_minus(N,L,ms,units,rel,HN,v_minus);
    if(M_minus == 0){
      std::cout<<"m^- equals to 0\n";
      continue;
    }
    fraction par1;//1+p-a_p
    fraction par2;//n(p,f)*2;
    for(int p=2;;p++){
      if(N%p==0) continue;
      if(!is_Prime(p)) continue;
      
      std::vector<fraction> T_p = Hecke_operator(p,N,ms,units,HN,pivot,rel,eigenspace_1);
      fraction ratio;//L(f,s)のq-展開のp次係数，a_p
      for(int i=0;i<T_p.size();i++){
        if(eigenspace_1[i] == 0) continue;
        ratio = T_p[i] / eigenspace_1[i];
        break;
      }
      for(int j=0;j<T_p.size();j++) assert(ratio * eigenspace_1[j] == T_p[j]);
      par1 = -ratio + 1 + p;
      par2 = n_pf(p,N,ms,units,eigenspace_1,rel,HN);
      break;
    }
    if(par2 == 0){
      std::cout<<"n(p,f) equals to 0\n";
      continue;
    }
    print_result(N,L,par1,par2,M_minus,Rectangular);
  }
}
